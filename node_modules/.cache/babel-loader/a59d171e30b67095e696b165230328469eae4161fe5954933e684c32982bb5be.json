{"ast":null,"code":"/*import React, { useState, useEffect } from \"react\";\r\nimport Calendar from \"react-calendar\";\r\nimport \"react-calendar/dist/Calendar.css\";\r\nimport \"../styles/Tracker.css\";\r\nimport Reports from \"./Reports\";\r\nimport { saveAs } from \"file-saver\"; \r\n\r\nfunction Tracker() {\r\n  const [date, setDate] = useState(new Date());\r\n  const [periodDates, setPeriodDates] = useState([]);\r\n\r\n  // Load stored period dates\r\n  useEffect(() => {\r\n    const savedDates = JSON.parse(localStorage.getItem(\"periodDates\"));\r\n    if (savedDates) {\r\n      setPeriodDates(savedDates);\r\n    }\r\n  }, []);\r\n\r\n  // Handle date selection\r\n  const handleDateChange = (selectedDate) => {\r\n    const formattedDate = selectedDate.toDateString();\r\n    if (!periodDates.includes(formattedDate)) {\r\n      const newDates = [...periodDates, formattedDate].sort((a, b) => new Date(a) - new Date(b));\r\n      setPeriodDates(newDates);\r\n      localStorage.setItem(\"periodDates\", JSON.stringify(newDates));\r\n      setDate(selectedDate);\r\n      showNotification(\"Period date logged!\");\r\n    }\r\n  };\r\n\r\n  // Delete period log\r\n  const deleteLog = (dateToDelete) => {\r\n    const updatedDates = periodDates.filter((d) => d !== dateToDelete);\r\n    setPeriodDates(updatedDates);\r\n    localStorage.setItem(\"periodDates\", JSON.stringify(updatedDates));\r\n  };\r\n\r\n  // Predict next period (assuming 28-day cycle)\r\n  const predictNextPeriod = () => {\r\n    if (periodDates.length > 0) {\r\n      let lastPeriod = new Date(periodDates[periodDates.length - 1]);\r\n      let nextPeriod = new Date(lastPeriod);\r\n      nextPeriod.setDate(nextPeriod.getDate() + 28);\r\n      return nextPeriod.toDateString();\r\n    }\r\n    return \"Not enough data to predict.\";\r\n  };\r\n\r\n  // Calculate cycle lengths\r\n  const cycleLengths = periodDates.map((date, i) => \r\n    i > 0 ? (new Date(date) - new Date(periodDates[i - 1])) / (1000 * 60 * 60 * 24) : null\r\n  ).filter(length => length !== null);\r\n\r\n  // Calculate average cycle length\r\n  const avgCycleLength = cycleLengths.length > 0 ? \r\n    (cycleLengths.reduce((a, b) => a + b, 0) / cycleLengths.length).toFixed(1) \r\n    : \"Not enough data\";\r\n\r\n  // Show browser notification\r\n  const showNotification = (message) => {\r\n    if (Notification.permission === \"granted\") {\r\n      new Notification(\"Menstrual Tracker\", { body: message });\r\n    }\r\n  };\r\n\r\n  // Export cycle data as CSV\r\n  const exportData = () => {\r\n    const csvContent = \"data:text/csv;charset=utf-8,Date\\n\" + periodDates.join(\"\\n\");\r\n    const blob = new Blob([csvContent], { type: \"text/csv;charset=utf-8;\" });\r\n    saveAs(blob, \"cycle_history.csv\");\r\n  };\r\n\r\n  return (\r\n    <div className=\"tracker-container\">\r\n      <h2>Menstrual Cycle Tracker</h2>\r\n      <Calendar onClickDay={handleDateChange} value={date} />\r\n      \r\n      <h3>Logged Period Dates:</h3>\r\n      <ul>\r\n        {periodDates.map((d, index) => (\r\n          <li key={index}>\r\n            {d} \r\n            <button onClick={() => deleteLog(d)}>‚ùé</button>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n\r\n      <h3>Next Predicted Period: {predictNextPeriod()}</h3>\r\n      <h3>Last Cycle Length: {cycleLengths.length > 0 ? cycleLengths[cycleLengths.length - 1] + \" days\" : \"N/A\"}</h3>\r\n      <h3>Average Cycle Length: {avgCycleLength}</h3> \r\n      \r\n      <button onClick={exportData}>üìÇ Export Cycle Data</button>\r\n\r\n      \r\n      <Reports periodDates={periodDates} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Tracker;\r\n*/\n\n/*\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Calendar from \"react-calendar\";\r\nimport \"react-calendar/dist/Calendar.css\";\r\nimport \"../styles/Tracker.css\";\r\nimport Reports from \"./Reports\";\r\nimport { saveAs } from \"file-saver\"; \r\n\r\nfunction Tracker() {\r\n  const [date, setDate] = useState(new Date());\r\n  const [periodDates, setPeriodDates] = useState([]);\r\n  const [cycleLength, setCycleLength] = useState(28); // Default cycle length\r\n\r\n  // Load stored period dates and cycle length\r\n  useEffect(() => {\r\n    const savedDates = JSON.parse(localStorage.getItem(\"periodDates\"));\r\n    if (savedDates) setPeriodDates(savedDates);\r\n\r\n    const savedCycleLength = localStorage.getItem(\"cycleLength\");\r\n    if (savedCycleLength) setCycleLength(Number(savedCycleLength));\r\n  }, []);\r\n\r\n  // Handle date selection\r\n  const handleDateChange = (selectedDate) => {\r\n    const formattedDate = selectedDate.toDateString();\r\n    if (!periodDates.includes(formattedDate)) {\r\n      const newDates = [...periodDates, formattedDate].sort((a, b) => new Date(a) - new Date(b));\r\n      setPeriodDates(newDates);\r\n      localStorage.setItem(\"periodDates\", JSON.stringify(newDates));\r\n      setDate(selectedDate);\r\n      showNotification(\"Period date logged!\");\r\n    }\r\n  };\r\n\r\n  // Delete period log\r\n  const deleteLog = (dateToDelete) => {\r\n    const updatedDates = periodDates.filter((d) => d !== dateToDelete);\r\n    setPeriodDates(updatedDates);\r\n    localStorage.setItem(\"periodDates\", JSON.stringify(updatedDates));\r\n  };\r\n\r\n  // Calculate cycle lengths\r\n  const cycleLengths = periodDates.map((date, i) => \r\n    i > 0 ? (new Date(date) - new Date(periodDates[i - 1])) / (1000 * 60 * 60 * 24) : null\r\n  ).filter(length => length !== null);\r\n\r\n  // Calculate average cycle length\r\n  const avgCycleLength = cycleLengths.length > 0 ? \r\n    Math.round(cycleLengths.reduce((a, b) => a + b, 0) / cycleLengths.length) \r\n    : 28; // Default to 28 if not enough data\r\n\r\n  // Predict next period based on user's actual cycle length or selected cycle length\r\n  const predictNextPeriod = () => {\r\n    if (periodDates.length > 0) {\r\n      let lastPeriod = new Date(periodDates[periodDates.length - 1]);\r\n      let nextPeriod = new Date(lastPeriod);\r\n      nextPeriod.setDate(nextPeriod.getDate() + cycleLength); // Use user-defined cycle length\r\n      return nextPeriod.toDateString();\r\n    }\r\n    return \"Not enough data to predict.\";\r\n  };\r\n\r\n  // Show browser notification\r\n  const showNotification = (message) => {\r\n    if (Notification.permission === \"granted\") {\r\n      new Notification(\"Menstrual Tracker\", { body: message });\r\n    }\r\n  };\r\n\r\n  // Handle cycle length change\r\n  const handleCycleLengthChange = (e) => {\r\n    const value = Number(e.target.value);\r\n    if (value > 15 && value < 50) { // Ensure valid range\r\n      setCycleLength(value);\r\n      localStorage.setItem(\"cycleLength\", value);\r\n    }\r\n  };\r\n\r\n  // Export cycle data as CSV\r\n  const exportData = () => {\r\n    const csvContent = \"data:text/csv;charset=utf-8,Date\\n\" + periodDates.join(\"\\n\");\r\n    const blob = new Blob([csvContent], { type: \"text/csv;charset=utf-8;\" });\r\n    saveAs(blob, \"cycle_history.csv\");\r\n  };\r\n\r\n  return (\r\n    <div className=\"tracker-container\">\r\n      <h2>Menstrual Cycle Tracker</h2>\r\n      <Calendar onClickDay={handleDateChange} value={date} />\r\n      \r\n      <h3>Logged Period Dates:</h3>\r\n      <ul>\r\n        {periodDates.map((d, index) => (\r\n          <li key={index}>\r\n            {d} \r\n            <button onClick={() => deleteLog(d)}>‚ùé</button>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n\r\n\r\n       {/*Allow user to manually set cycle length \r\n      <label>Set Your Cycle Length: </label>\r\n      <input \r\n        type=\"number\" \r\n        value={cycleLength} \r\n        onChange={handleCycleLengthChange} \r\n        min=\"15\" \r\n        max=\"50\"\r\n      />\r\n\r\n      \r\n\r\n      <h3>Next Predicted Period: {predictNextPeriod()}</h3>\r\n      <h3>Last Cycle Length: {cycleLengths.length > 0 ? cycleLengths[cycleLengths.length - 1] + \" days\" : \"N/A\"}</h3>\r\n      <h3>Average Cycle Length: {avgCycleLength} days</h3>\r\n\r\n      \r\n\r\n      <button onClick={exportData}>üìÇ Export Cycle Data</button>\r\n\r\n      {/* Integrating Reports \r\n      <Reports periodDates={periodDates} \r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Tracker;\r\n*/\n\n/*\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Calendar from \"react-calendar\";\r\nimport \"react-calendar/dist/Calendar.css\";\r\nimport \"../styles/Tracker.css\";\r\nimport Reports from \"./Reports\";\r\nimport { saveAs } from \"file-saver\";\r\n\r\nfunction Tracker() {\r\n  // eslint-disable-next-line no-unused-vars\r\n  const [date, setDate] = useState(new Date());\r\n  const [periodRecords, setPeriodRecords] = useState([]);\r\n  const [cycleLength, setCycleLength] = useState(28); // Default cycle length\r\n  const [message, setMessage] = useState(\"\");\r\n\r\n  // Load stored period dates and cycle length\r\n  useEffect(() => {\r\n    const fetchPeriodRecords = async () => {\r\n      try {\r\n        const response = await fetch(\"http://localhost:3000/api/cycles/history\", {\r\n          headers: {\r\n            Authorization: `Bearer ${localStorage.getItem(\"token\")}`,\r\n          },\r\n        });\r\n        if (response.ok) {\r\n          const data = await response.json();\r\n          setPeriodRecords(data);\r\n          if (data.length > 0) {\r\n            setCycleLength(data[0].cycleLength);\r\n          }\r\n        } else {\r\n          setMessage(\"Failed to fetch period records.\");\r\n        }\r\n      } catch (error) {\r\n        setMessage(\"Error fetching period records.\");\r\n      }\r\n    };\r\n\r\n    fetchPeriodRecords();\r\n  }, []);\r\n\r\n  // Handle date selection\r\n  const handleDateChange = async (selectedDate) => {\r\n    const formattedDate = selectedDate.toISOString().split(\"T\")[0];\r\n    if (!periodRecords.some((record) => record.startDate === formattedDate)) {\r\n      try {\r\n        const response = await fetch(\"http://localhost:3000/api/cycles/log\", {\r\n          method: \"POST\",\r\n          headers: {\r\n            \"Content-Type\": \"application/json\",\r\n            Authorization: `Bearer ${localStorage.getItem(\"token\")}`,\r\n          },\r\n          body: JSON.stringify({ startDate: formattedDate, cycleLength }),\r\n        });\r\n\r\n        if (response.ok) {\r\n          const newRecord = await response.json();\r\n          setPeriodRecords((prevRecords) =>\r\n            [...prevRecords, newRecord].sort(\r\n              (a, b) => new Date(a.startDate) - new Date(b.startDate)\r\n            )\r\n          );\r\n          setMessage(\"Period date logged!\");\r\n        } else {\r\n          setMessage(\"Failed to log period date.\");\r\n        }\r\n      } catch (error) {\r\n        setMessage(\"Error logging period date.\");\r\n      }\r\n    }\r\n  };\r\n\r\n  // Delete period log\r\n  const deleteLog = async (recordId) => {\r\n    try {\r\n      const response = await fetch(`http://localhost:3000/api/cycles/${recordId}`, {\r\n        method: \"DELETE\",\r\n        headers: {\r\n          Authorization: `Bearer ${localStorage.getItem(\"token\")}`,\r\n        },\r\n      });\r\n\r\n      if (response.ok) {\r\n        setPeriodRecords((prevRecords) =>\r\n          prevRecords.filter((record) => record._id !== recordId)\r\n        );\r\n        setMessage(\"Period record deleted.\");\r\n      } else {\r\n        setMessage(\"Failed to delete period record.\");\r\n      }\r\n    } catch (error) {\r\n      setMessage(\"Error deleting period record.\");\r\n    }\r\n  };\r\n\r\n  // Calculate cycle lengths\r\n  const cycleLengths = periodRecords\r\n    .map((record, i) =>\r\n      i > 0\r\n        ? (new Date(record.startDate) -\r\n            new Date(periodRecords[i - 1].startDate)) /\r\n          (1000 * 60 * 60 * 24)\r\n        : null\r\n    )\r\n    .filter((length) => length !== null);\r\n\r\n  const avgCycleLength =\r\n    cycleLengths.length > 0\r\n      ? Math.round(cycleLengths.reduce((a, b) => a + b, 0) / cycleLengths.length)\r\n      : 28;\r\n\r\n  const predictNextPeriod = () => {\r\n    if (periodRecords.length > 0) {\r\n      let lastPeriod = new Date(periodRecords[periodRecords.length - 1].startDate);\r\n      let nextPeriod = new Date(lastPeriod);\r\n      nextPeriod.setDate(nextPeriod.getDate() + cycleLength);\r\n      return nextPeriod.toDateString();\r\n    }\r\n    return \"Not enough data to predict.\";\r\n  };\r\n\r\n  // Show browser notification\r\n  // eslint-disable-next-line no-unused-vars\r\n  const showNotification = (message) => {\r\n    if (Notification.permission === \"granted\") {\r\n      new Notification(\"Menstrual Tracker\", { body: message });\r\n    } else if (Notification.permission !== \"denied\") {\r\n      Notification.requestPermission().then((permission) => {\r\n        if (permission === \"granted\") {\r\n          new Notification(\"Menstrual Tracker\", { body: message });\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  // Handle cycle length change\r\n  const handleCycleLengthChange = async (e) => {\r\n    const value = Number(e.target.value);\r\n    if (value > 15 && value < 50) {\r\n      setCycleLength(value);\r\n      try {\r\n        const response = await fetch(\r\n          \"http://localhost:3000/api/cycles/update-cycle-length\",\r\n          {\r\n            method: \"PUT\",\r\n            headers: {\r\n              \"Content-Type\": \"application/json\",\r\n              Authorization: `Bearer ${localStorage.getItem(\"token\")}`,\r\n            },\r\n            body: JSON.stringify({ cycleLength: value }),\r\n          }\r\n        );\r\n\r\n        if (response.ok) {\r\n          setMessage(\"Cycle length updated.\");\r\n        } else {\r\n          setMessage(\"Failed to update cycle length.\");\r\n        }\r\n      } catch (error) {\r\n        setMessage(\"Error updating cycle length.\");\r\n      }\r\n    }\r\n  };\r\n\r\n  // Export cycle data as CSV\r\n  const exportData = () => {\r\n    const periodDates = periodRecords.map((record) => record.startDate);\r\n    const csvContent =\r\n      \"data:text/csv;charset=utf-8,Date\\n\" + periodDates.join(\"\\n\");\r\n    const blob = new Blob([csvContent], { type: \"text/csv;charset=utf-8;\" });\r\n    saveAs(blob, \"cycle_history.csv\");\r\n  };\r\n\r\n  // Define periodDates for use in Reports component\r\n  const periodDates = periodRecords.map((record) => record.startDate);\r\n\r\n  return (\r\n    <div>\r\n      <h1>Menstrual Health Tracker</h1>\r\n      <div>\r\n        {/* Calendar Component \r\n        <Calendar onChange={handleDateChange} value={date} />\r\n      </div>\r\n      <div>\r\n        {/* Cycle Length Input \r\n        <label>\r\n          Cycle Length:\r\n          <input\r\n            type=\"number\"\r\n            value={cycleLength}\r\n            onChange={handleCycleLengthChange}\r\n            min=\"15\"\r\n            max=\"50\"\r\n          />\r\n        </label>\r\n      </div>\r\n      <div>\r\n        <h2>Period Records</h2>\r\n        <ul>\r\n          {periodRecords.map((record) => (\r\n            <li key={record._id}>\r\n              {record.startDate}\r\n              <button onClick={() => deleteLog(record._id)}>Delete</button>\r\n            </li>\r\n          ))}\r\n        </ul>\r\n      </div>\r\n      <div>\r\n\r\n      \r\n\r\n        {/* Additional Features \r\n        <h3>Next Predicted Period: {predictNextPeriod()}</h3>\r\n        <h3>\r\n          Last Cycle Length:{\" \"}\r\n          {cycleLengths.length > 0\r\n            ? cycleLengths[cycleLengths.length - 1] + \" days\"\r\n            : \"N/A\"}\r\n        </h3>\r\n        <h3>Average Cycle Length: {avgCycleLength} days</h3>\r\n        <button onClick={exportData}>üìÇ Export Cycle Data</button>\r\n      </div>\r\n      {/* Reports Component \r\n      <Reports periodDates={periodDates} />\r\n      {/* Message Display \r\n      {message && <p>{message}</p>}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Tracker;\r\n*/","map":{"version":3,"names":[],"sources":["C:/vardha/Menstrual/frontend/src/pages/Tracker.js"],"sourcesContent":["/*import React, { useState, useEffect } from \"react\";\r\nimport Calendar from \"react-calendar\";\r\nimport \"react-calendar/dist/Calendar.css\";\r\nimport \"../styles/Tracker.css\";\r\nimport Reports from \"./Reports\";\r\nimport { saveAs } from \"file-saver\"; \r\n\r\nfunction Tracker() {\r\n  const [date, setDate] = useState(new Date());\r\n  const [periodDates, setPeriodDates] = useState([]);\r\n\r\n  // Load stored period dates\r\n  useEffect(() => {\r\n    const savedDates = JSON.parse(localStorage.getItem(\"periodDates\"));\r\n    if (savedDates) {\r\n      setPeriodDates(savedDates);\r\n    }\r\n  }, []);\r\n\r\n  // Handle date selection\r\n  const handleDateChange = (selectedDate) => {\r\n    const formattedDate = selectedDate.toDateString();\r\n    if (!periodDates.includes(formattedDate)) {\r\n      const newDates = [...periodDates, formattedDate].sort((a, b) => new Date(a) - new Date(b));\r\n      setPeriodDates(newDates);\r\n      localStorage.setItem(\"periodDates\", JSON.stringify(newDates));\r\n      setDate(selectedDate);\r\n      showNotification(\"Period date logged!\");\r\n    }\r\n  };\r\n\r\n  // Delete period log\r\n  const deleteLog = (dateToDelete) => {\r\n    const updatedDates = periodDates.filter((d) => d !== dateToDelete);\r\n    setPeriodDates(updatedDates);\r\n    localStorage.setItem(\"periodDates\", JSON.stringify(updatedDates));\r\n  };\r\n\r\n  // Predict next period (assuming 28-day cycle)\r\n  const predictNextPeriod = () => {\r\n    if (periodDates.length > 0) {\r\n      let lastPeriod = new Date(periodDates[periodDates.length - 1]);\r\n      let nextPeriod = new Date(lastPeriod);\r\n      nextPeriod.setDate(nextPeriod.getDate() + 28);\r\n      return nextPeriod.toDateString();\r\n    }\r\n    return \"Not enough data to predict.\";\r\n  };\r\n\r\n  // Calculate cycle lengths\r\n  const cycleLengths = periodDates.map((date, i) => \r\n    i > 0 ? (new Date(date) - new Date(periodDates[i - 1])) / (1000 * 60 * 60 * 24) : null\r\n  ).filter(length => length !== null);\r\n\r\n  // Calculate average cycle length\r\n  const avgCycleLength = cycleLengths.length > 0 ? \r\n    (cycleLengths.reduce((a, b) => a + b, 0) / cycleLengths.length).toFixed(1) \r\n    : \"Not enough data\";\r\n\r\n  // Show browser notification\r\n  const showNotification = (message) => {\r\n    if (Notification.permission === \"granted\") {\r\n      new Notification(\"Menstrual Tracker\", { body: message });\r\n    }\r\n  };\r\n\r\n  // Export cycle data as CSV\r\n  const exportData = () => {\r\n    const csvContent = \"data:text/csv;charset=utf-8,Date\\n\" + periodDates.join(\"\\n\");\r\n    const blob = new Blob([csvContent], { type: \"text/csv;charset=utf-8;\" });\r\n    saveAs(blob, \"cycle_history.csv\");\r\n  };\r\n\r\n  return (\r\n    <div className=\"tracker-container\">\r\n      <h2>Menstrual Cycle Tracker</h2>\r\n      <Calendar onClickDay={handleDateChange} value={date} />\r\n      \r\n      <h3>Logged Period Dates:</h3>\r\n      <ul>\r\n        {periodDates.map((d, index) => (\r\n          <li key={index}>\r\n            {d} \r\n            <button onClick={() => deleteLog(d)}>‚ùé</button>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n\r\n      <h3>Next Predicted Period: {predictNextPeriod()}</h3>\r\n      <h3>Last Cycle Length: {cycleLengths.length > 0 ? cycleLengths[cycleLengths.length - 1] + \" days\" : \"N/A\"}</h3>\r\n      <h3>Average Cycle Length: {avgCycleLength}</h3> \r\n      \r\n      <button onClick={exportData}>üìÇ Export Cycle Data</button>\r\n\r\n      \r\n      <Reports periodDates={periodDates} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Tracker;\r\n*/\r\n\r\n\r\n/*\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Calendar from \"react-calendar\";\r\nimport \"react-calendar/dist/Calendar.css\";\r\nimport \"../styles/Tracker.css\";\r\nimport Reports from \"./Reports\";\r\nimport { saveAs } from \"file-saver\"; \r\n\r\nfunction Tracker() {\r\n  const [date, setDate] = useState(new Date());\r\n  const [periodDates, setPeriodDates] = useState([]);\r\n  const [cycleLength, setCycleLength] = useState(28); // Default cycle length\r\n\r\n  // Load stored period dates and cycle length\r\n  useEffect(() => {\r\n    const savedDates = JSON.parse(localStorage.getItem(\"periodDates\"));\r\n    if (savedDates) setPeriodDates(savedDates);\r\n\r\n    const savedCycleLength = localStorage.getItem(\"cycleLength\");\r\n    if (savedCycleLength) setCycleLength(Number(savedCycleLength));\r\n  }, []);\r\n\r\n  // Handle date selection\r\n  const handleDateChange = (selectedDate) => {\r\n    const formattedDate = selectedDate.toDateString();\r\n    if (!periodDates.includes(formattedDate)) {\r\n      const newDates = [...periodDates, formattedDate].sort((a, b) => new Date(a) - new Date(b));\r\n      setPeriodDates(newDates);\r\n      localStorage.setItem(\"periodDates\", JSON.stringify(newDates));\r\n      setDate(selectedDate);\r\n      showNotification(\"Period date logged!\");\r\n    }\r\n  };\r\n\r\n  // Delete period log\r\n  const deleteLog = (dateToDelete) => {\r\n    const updatedDates = periodDates.filter((d) => d !== dateToDelete);\r\n    setPeriodDates(updatedDates);\r\n    localStorage.setItem(\"periodDates\", JSON.stringify(updatedDates));\r\n  };\r\n\r\n  // Calculate cycle lengths\r\n  const cycleLengths = periodDates.map((date, i) => \r\n    i > 0 ? (new Date(date) - new Date(periodDates[i - 1])) / (1000 * 60 * 60 * 24) : null\r\n  ).filter(length => length !== null);\r\n\r\n  // Calculate average cycle length\r\n  const avgCycleLength = cycleLengths.length > 0 ? \r\n    Math.round(cycleLengths.reduce((a, b) => a + b, 0) / cycleLengths.length) \r\n    : 28; // Default to 28 if not enough data\r\n\r\n  // Predict next period based on user's actual cycle length or selected cycle length\r\n  const predictNextPeriod = () => {\r\n    if (periodDates.length > 0) {\r\n      let lastPeriod = new Date(periodDates[periodDates.length - 1]);\r\n      let nextPeriod = new Date(lastPeriod);\r\n      nextPeriod.setDate(nextPeriod.getDate() + cycleLength); // Use user-defined cycle length\r\n      return nextPeriod.toDateString();\r\n    }\r\n    return \"Not enough data to predict.\";\r\n  };\r\n\r\n  // Show browser notification\r\n  const showNotification = (message) => {\r\n    if (Notification.permission === \"granted\") {\r\n      new Notification(\"Menstrual Tracker\", { body: message });\r\n    }\r\n  };\r\n\r\n  // Handle cycle length change\r\n  const handleCycleLengthChange = (e) => {\r\n    const value = Number(e.target.value);\r\n    if (value > 15 && value < 50) { // Ensure valid range\r\n      setCycleLength(value);\r\n      localStorage.setItem(\"cycleLength\", value);\r\n    }\r\n  };\r\n\r\n  // Export cycle data as CSV\r\n  const exportData = () => {\r\n    const csvContent = \"data:text/csv;charset=utf-8,Date\\n\" + periodDates.join(\"\\n\");\r\n    const blob = new Blob([csvContent], { type: \"text/csv;charset=utf-8;\" });\r\n    saveAs(blob, \"cycle_history.csv\");\r\n  };\r\n\r\n  return (\r\n    <div className=\"tracker-container\">\r\n      <h2>Menstrual Cycle Tracker</h2>\r\n      <Calendar onClickDay={handleDateChange} value={date} />\r\n      \r\n      <h3>Logged Period Dates:</h3>\r\n      <ul>\r\n        {periodDates.map((d, index) => (\r\n          <li key={index}>\r\n            {d} \r\n            <button onClick={() => deleteLog(d)}>‚ùé</button>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n\r\n\r\n       {/*Allow user to manually set cycle length \r\n      <label>Set Your Cycle Length: </label>\r\n      <input \r\n        type=\"number\" \r\n        value={cycleLength} \r\n        onChange={handleCycleLengthChange} \r\n        min=\"15\" \r\n        max=\"50\"\r\n      />\r\n\r\n      \r\n\r\n      <h3>Next Predicted Period: {predictNextPeriod()}</h3>\r\n      <h3>Last Cycle Length: {cycleLengths.length > 0 ? cycleLengths[cycleLengths.length - 1] + \" days\" : \"N/A\"}</h3>\r\n      <h3>Average Cycle Length: {avgCycleLength} days</h3>\r\n\r\n      \r\n\r\n      <button onClick={exportData}>üìÇ Export Cycle Data</button>\r\n\r\n      {/* Integrating Reports \r\n      <Reports periodDates={periodDates} \r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Tracker;\r\n*/\r\n\r\n\r\n/*\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Calendar from \"react-calendar\";\r\nimport \"react-calendar/dist/Calendar.css\";\r\nimport \"../styles/Tracker.css\";\r\nimport Reports from \"./Reports\";\r\nimport { saveAs } from \"file-saver\";\r\n\r\nfunction Tracker() {\r\n  // eslint-disable-next-line no-unused-vars\r\n  const [date, setDate] = useState(new Date());\r\n  const [periodRecords, setPeriodRecords] = useState([]);\r\n  const [cycleLength, setCycleLength] = useState(28); // Default cycle length\r\n  const [message, setMessage] = useState(\"\");\r\n\r\n  // Load stored period dates and cycle length\r\n  useEffect(() => {\r\n    const fetchPeriodRecords = async () => {\r\n      try {\r\n        const response = await fetch(\"http://localhost:3000/api/cycles/history\", {\r\n          headers: {\r\n            Authorization: `Bearer ${localStorage.getItem(\"token\")}`,\r\n          },\r\n        });\r\n        if (response.ok) {\r\n          const data = await response.json();\r\n          setPeriodRecords(data);\r\n          if (data.length > 0) {\r\n            setCycleLength(data[0].cycleLength);\r\n          }\r\n        } else {\r\n          setMessage(\"Failed to fetch period records.\");\r\n        }\r\n      } catch (error) {\r\n        setMessage(\"Error fetching period records.\");\r\n      }\r\n    };\r\n\r\n    fetchPeriodRecords();\r\n  }, []);\r\n\r\n  // Handle date selection\r\n  const handleDateChange = async (selectedDate) => {\r\n    const formattedDate = selectedDate.toISOString().split(\"T\")[0];\r\n    if (!periodRecords.some((record) => record.startDate === formattedDate)) {\r\n      try {\r\n        const response = await fetch(\"http://localhost:3000/api/cycles/log\", {\r\n          method: \"POST\",\r\n          headers: {\r\n            \"Content-Type\": \"application/json\",\r\n            Authorization: `Bearer ${localStorage.getItem(\"token\")}`,\r\n          },\r\n          body: JSON.stringify({ startDate: formattedDate, cycleLength }),\r\n        });\r\n\r\n        if (response.ok) {\r\n          const newRecord = await response.json();\r\n          setPeriodRecords((prevRecords) =>\r\n            [...prevRecords, newRecord].sort(\r\n              (a, b) => new Date(a.startDate) - new Date(b.startDate)\r\n            )\r\n          );\r\n          setMessage(\"Period date logged!\");\r\n        } else {\r\n          setMessage(\"Failed to log period date.\");\r\n        }\r\n      } catch (error) {\r\n        setMessage(\"Error logging period date.\");\r\n      }\r\n    }\r\n  };\r\n\r\n  // Delete period log\r\n  const deleteLog = async (recordId) => {\r\n    try {\r\n      const response = await fetch(`http://localhost:3000/api/cycles/${recordId}`, {\r\n        method: \"DELETE\",\r\n        headers: {\r\n          Authorization: `Bearer ${localStorage.getItem(\"token\")}`,\r\n        },\r\n      });\r\n\r\n      if (response.ok) {\r\n        setPeriodRecords((prevRecords) =>\r\n          prevRecords.filter((record) => record._id !== recordId)\r\n        );\r\n        setMessage(\"Period record deleted.\");\r\n      } else {\r\n        setMessage(\"Failed to delete period record.\");\r\n      }\r\n    } catch (error) {\r\n      setMessage(\"Error deleting period record.\");\r\n    }\r\n  };\r\n\r\n  // Calculate cycle lengths\r\n  const cycleLengths = periodRecords\r\n    .map((record, i) =>\r\n      i > 0\r\n        ? (new Date(record.startDate) -\r\n            new Date(periodRecords[i - 1].startDate)) /\r\n          (1000 * 60 * 60 * 24)\r\n        : null\r\n    )\r\n    .filter((length) => length !== null);\r\n\r\n  const avgCycleLength =\r\n    cycleLengths.length > 0\r\n      ? Math.round(cycleLengths.reduce((a, b) => a + b, 0) / cycleLengths.length)\r\n      : 28;\r\n\r\n  const predictNextPeriod = () => {\r\n    if (periodRecords.length > 0) {\r\n      let lastPeriod = new Date(periodRecords[periodRecords.length - 1].startDate);\r\n      let nextPeriod = new Date(lastPeriod);\r\n      nextPeriod.setDate(nextPeriod.getDate() + cycleLength);\r\n      return nextPeriod.toDateString();\r\n    }\r\n    return \"Not enough data to predict.\";\r\n  };\r\n\r\n  // Show browser notification\r\n  // eslint-disable-next-line no-unused-vars\r\n  const showNotification = (message) => {\r\n    if (Notification.permission === \"granted\") {\r\n      new Notification(\"Menstrual Tracker\", { body: message });\r\n    } else if (Notification.permission !== \"denied\") {\r\n      Notification.requestPermission().then((permission) => {\r\n        if (permission === \"granted\") {\r\n          new Notification(\"Menstrual Tracker\", { body: message });\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  // Handle cycle length change\r\n  const handleCycleLengthChange = async (e) => {\r\n    const value = Number(e.target.value);\r\n    if (value > 15 && value < 50) {\r\n      setCycleLength(value);\r\n      try {\r\n        const response = await fetch(\r\n          \"http://localhost:3000/api/cycles/update-cycle-length\",\r\n          {\r\n            method: \"PUT\",\r\n            headers: {\r\n              \"Content-Type\": \"application/json\",\r\n              Authorization: `Bearer ${localStorage.getItem(\"token\")}`,\r\n            },\r\n            body: JSON.stringify({ cycleLength: value }),\r\n          }\r\n        );\r\n\r\n        if (response.ok) {\r\n          setMessage(\"Cycle length updated.\");\r\n        } else {\r\n          setMessage(\"Failed to update cycle length.\");\r\n        }\r\n      } catch (error) {\r\n        setMessage(\"Error updating cycle length.\");\r\n      }\r\n    }\r\n  };\r\n\r\n  // Export cycle data as CSV\r\n  const exportData = () => {\r\n    const periodDates = periodRecords.map((record) => record.startDate);\r\n    const csvContent =\r\n      \"data:text/csv;charset=utf-8,Date\\n\" + periodDates.join(\"\\n\");\r\n    const blob = new Blob([csvContent], { type: \"text/csv;charset=utf-8;\" });\r\n    saveAs(blob, \"cycle_history.csv\");\r\n  };\r\n\r\n  // Define periodDates for use in Reports component\r\n  const periodDates = periodRecords.map((record) => record.startDate);\r\n\r\n  return (\r\n    <div>\r\n      <h1>Menstrual Health Tracker</h1>\r\n      <div>\r\n        {/* Calendar Component \r\n        <Calendar onChange={handleDateChange} value={date} />\r\n      </div>\r\n      <div>\r\n        {/* Cycle Length Input \r\n        <label>\r\n          Cycle Length:\r\n          <input\r\n            type=\"number\"\r\n            value={cycleLength}\r\n            onChange={handleCycleLengthChange}\r\n            min=\"15\"\r\n            max=\"50\"\r\n          />\r\n        </label>\r\n      </div>\r\n      <div>\r\n        <h2>Period Records</h2>\r\n        <ul>\r\n          {periodRecords.map((record) => (\r\n            <li key={record._id}>\r\n              {record.startDate}\r\n              <button onClick={() => deleteLog(record._id)}>Delete</button>\r\n            </li>\r\n          ))}\r\n        </ul>\r\n      </div>\r\n      <div>\r\n\r\n      \r\n\r\n        {/* Additional Features \r\n        <h3>Next Predicted Period: {predictNextPeriod()}</h3>\r\n        <h3>\r\n          Last Cycle Length:{\" \"}\r\n          {cycleLengths.length > 0\r\n            ? cycleLengths[cycleLengths.length - 1] + \" days\"\r\n            : \"N/A\"}\r\n        </h3>\r\n        <h3>Average Cycle Length: {avgCycleLength} days</h3>\r\n        <button onClick={exportData}>üìÇ Export Cycle Data</button>\r\n      </div>\r\n      {/* Reports Component \r\n      <Reports periodDates={periodDates} />\r\n      {/* Message Display \r\n      {message && <p>{message}</p>}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Tracker;\r\n*/"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}